
#ifdef HAVE_CONFIG_H
#include "../../ext_config.h"
#endif

#include <php.h>
#include "../../php_ext.h"
#include "../../ext.h"

#include <Zend/zend_operators.h>
#include <Zend/zend_exceptions.h>
#include <Zend/zend_interfaces.h>

#include "kernel/main.h"
#include "kernel/object.h"
#include "kernel/memory.h"
#include "ext/spl/spl_exceptions.h"
#include "kernel/exception.h"
#include "kernel/operators.h"
#include "kernel/time.h"
#include "kernel/fcall.h"


/**
 * CacheItemInterface defines an interface for interacting with objects inside a cache.
 *
 * Each Item object MUST be associated with a specific key, which can be set
 * according to the implementing system and is typically passed by the
 * Cache\CacheItemPoolInterface object.
 *
 * The Cache\CacheItemInterface object encapsulates the storage and retrieval of
 * cache items. Each Cache\CacheItemInterface is generated by a
 * Cache\CacheItemPoolInterface object, which is responsible for any required
 * setup as well as associating the object with a unique Key.
 * Cache\CacheItemInterface objects MUST be able to store and retrieve any type
 * of PHP value defined in the Data section of the specification.
 *
 * Calling Libraries MUST NOT instantiate Item objects themselves. They may only
 * be requested from a Pool object via the getItem() method.  Calling Libraries
 * SHOULD NOT assume that an Item created by one Implementing Library is
 * compatible with a Pool from another Implementing Library.
 */
ZEPHIR_INIT_CLASS(Xpl_Cache_Item) {

	ZEPHIR_REGISTER_CLASS(Xpl\\Cache, Item, xpl, cache_item, xpl_cache_item_method_entry, 0);

	/**
	 * @var string
	 */
	zend_declare_property_null(xpl_cache_item_ce, SL("key"), ZEND_ACC_PRIVATE TSRMLS_CC);

	/**
	 * @var boolean
	 */
	zend_declare_property_null(xpl_cache_item_ce, SL("hit"), ZEND_ACC_PRIVATE TSRMLS_CC);

	/**
	 * @var mixed
	 */
	zend_declare_property_null(xpl_cache_item_ce, SL("value"), ZEND_ACC_PROTECTED TSRMLS_CC);

	/**
	 * @var int
	 */
	zend_declare_property_null(xpl_cache_item_ce, SL("expires"), ZEND_ACC_PROTECTED TSRMLS_CC);

	/**
	 * @var int
	 */
	zend_declare_property_null(xpl_cache_item_ce, SL("defaultTtl"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(xpl_cache_item_ce TSRMLS_CC, 1, zephir_get_internal_ce(SS("psr\\cache\\cacheiteminterface") TSRMLS_CC));
	return SUCCESS;

}

/**
 * Constructor.
 *
 * @param int defaultTtl
 */
PHP_METHOD(Xpl_Cache_Item, __construct) {

	int expiry, defaultTtl;
	zend_bool hit;
	zval *key_param = NULL, *hit_param = NULL, *value, *expiry_param = NULL, *defaultTtl_param = NULL, *_0;
	zval *key = NULL;

	ZEPHIR_MM_GROW();
	zephir_fetch_params(1, 3, 2, &key_param, &hit_param, &value, &expiry_param, &defaultTtl_param);

	if (unlikely(Z_TYPE_P(key_param) != IS_STRING && Z_TYPE_P(key_param) != IS_NULL)) {
		zephir_throw_exception_string(spl_ce_InvalidArgumentException, SL("Parameter 'key' must be a string") TSRMLS_CC);
		RETURN_MM_NULL();
	}
	if (likely(Z_TYPE_P(key_param) == IS_STRING)) {
		zephir_get_strval(key, key_param);
	} else {
		ZEPHIR_INIT_VAR(key);
		ZVAL_EMPTY_STRING(key);
	}
	if (unlikely(Z_TYPE_P(hit_param) != IS_BOOL)) {
		zephir_throw_exception_string(spl_ce_InvalidArgumentException, SL("Parameter 'hit' must be a bool") TSRMLS_CC);
		RETURN_MM_NULL();
	}
	hit = Z_BVAL_P(hit_param);
	if (!expiry_param) {
		expiry = 0;
	} else {
		expiry = zephir_get_intval(expiry_param);
	}
	if (!defaultTtl_param) {
		defaultTtl = 0;
	} else {
		defaultTtl = zephir_get_intval(defaultTtl_param);
	}


	zephir_update_property_this(this_ptr, SL("key"), key TSRMLS_CC);
	if (hit) {
		zephir_update_property_this(this_ptr, SL("hit"), ZEPHIR_GLOBAL(global_true) TSRMLS_CC);
	} else {
		zephir_update_property_this(this_ptr, SL("hit"), ZEPHIR_GLOBAL(global_false) TSRMLS_CC);
	}
	zephir_update_property_this(this_ptr, SL("value"), value TSRMLS_CC);
	ZEPHIR_INIT_ZVAL_NREF(_0);
	ZVAL_LONG(_0, expiry);
	zephir_update_property_this(this_ptr, SL("expires"), _0 TSRMLS_CC);
	ZEPHIR_INIT_ZVAL_NREF(_0);
	ZVAL_LONG(_0, defaultTtl);
	zephir_update_property_this(this_ptr, SL("defaultTtl"), _0 TSRMLS_CC);
	ZEPHIR_MM_RESTORE();

}

/**
 * Returns the key for the current cache item.
 *
 * The key is loaded by the Implementing Library, but should be available to
 * the higher level callers when needed.
 *
 * @return string The key string for this cache item.
 */
PHP_METHOD(Xpl_Cache_Item, getKey) {

	

	RETURN_MEMBER(this_ptr, "key");

}

/**
 * Retrieves the value of the item from the cache associated with this object's key.
 *
 * The value returned must be identical to the value originally stored by set().
 *
 * If isHit() returns false, this method MUST return null. Note that null
 * is a legitimate cached value, so the isHit() method SHOULD be used to
 * differentiate between "null value was found" and "no value was found."
 *
 * @return mixed The value corresponding to this cache item's key, or null if not found.
 */
PHP_METHOD(Xpl_Cache_Item, get) {

	

	RETURN_MEMBER(this_ptr, "value");

}

/**
 * Confirms if the cache item lookup resulted in a cache hit.
 *
 * Note: This method MUST NOT have a race condition between calling isHit()
 * and calling get().
 *
 * @return bool True if the request resulted in a cache hit. False otherwise.
 */
PHP_METHOD(Xpl_Cache_Item, isHit) {

	

	RETURN_MEMBER(this_ptr, "hit");

}

/**
 * Sets the value represented by this cache item.
 *
 * The value argument may be any item that can be serialized by PHP,
 * although the method of serialization is left up to the Implementing
 * Library.
 *
 * @param mixed value The serializable value to be stored.
 *
 * @return \Xpl\Cache\Item The invoked object.
 */
PHP_METHOD(Xpl_Cache_Item, set) {

	zval *value;

	zephir_fetch_params(0, 1, 0, &value);



	zephir_update_property_this(this_ptr, SL("value"), value TSRMLS_CC);
	RETURN_THISW();

}

/**
 * Sets the expiration time for this cache item.
 *
 * @param \DateTimeInterface expiration
 *   The point in time after which the item MUST be considered expired.
 *   If null is passed explicitly, a default value MAY be used. If none is set,
 *   the value should be stored permanently or for as long as the
 *   implementation allows.
 *
 * @return \Xpl\Cache\Item The called object.
 */
PHP_METHOD(Xpl_Cache_Item, expiresAt) {

	int ZEPHIR_LAST_CALL_STATUS;
	zval *expiration, *_0$$3, *_1$$3, *_2$$3, *_3$$5 = NULL, *_4$$5, *_5$$5, *_6$$6, *_7$$6 = NULL, _8$$6, *_9$$6 = NULL;

	ZEPHIR_MM_GROW();
	zephir_fetch_params(1, 1, 0, &expiration);



	if (Z_TYPE_P(expiration) == IS_NULL) {
		ZEPHIR_INIT_VAR(_0$$3);
		zephir_time(_0$$3);
		_1$$3 = zephir_fetch_nproperty_this(this_ptr, SL("defaultTtl"), PH_NOISY_CC);
		ZEPHIR_INIT_VAR(_2$$3);
		zephir_add_function(_2$$3, _0$$3, _1$$3);
		zephir_update_property_this(this_ptr, SL("expires"), _2$$3 TSRMLS_CC);
	} else {
		if (zephir_is_instance_of(expiration, SL("DateTimeInterface") TSRMLS_CC)) {
			ZEPHIR_INIT_VAR(_4$$5);
			ZVAL_STRING(_4$$5, "U", ZEPHIR_TEMP_PARAM_COPY);
			ZEPHIR_CALL_METHOD(&_3$$5, expiration, "format", NULL, 0, _4$$5);
			zephir_check_temp_parameter(_4$$5);
			zephir_check_call_status();
			ZEPHIR_INIT_ZVAL_NREF(_5$$5);
			ZVAL_LONG(_5$$5, zephir_get_intval(_3$$5));
			zephir_update_property_this(this_ptr, SL("expires"), _5$$5 TSRMLS_CC);
		} else {
			ZEPHIR_INIT_VAR(_6$$6);
			object_init_ex(_6$$6, xpl_cache_invalidargumentexception_ce);
			ZEPHIR_INIT_VAR(_7$$6);
			if (Z_TYPE_P(expiration) == IS_OBJECT) {
				ZEPHIR_INIT_NVAR(_7$$6);
				zephir_get_class(_7$$6, expiration, 0 TSRMLS_CC);
			} else {
				ZEPHIR_INIT_NVAR(_7$$6);
				zephir_gettype(_7$$6, expiration TSRMLS_CC);
			}
			ZEPHIR_SINIT_VAR(_8$$6);
			ZVAL_STRING(&_8$$6, "Expiration date must be null or instance of DateTimeInterface, given: \"%s\".", 0);
			ZEPHIR_CALL_FUNCTION(&_9$$6, "sprintf", NULL, 41, &_8$$6, _7$$6);
			zephir_check_call_status();
			ZEPHIR_CALL_METHOD(NULL, _6$$6, "__construct", NULL, 42, _9$$6);
			zephir_check_call_status();
			zephir_throw_exception_debug(_6$$6, "xpl/cache/item.zep", 147 TSRMLS_CC);
			ZEPHIR_MM_RESTORE();
			return;
		}
	}
	RETURN_THIS();

}

/**
 * Sets the expiration time for this cache item.
 *
 * @param int|\DateInterval time
 *   The period of time from the present after which the item MUST be considered
 *   expired. An integer parameter is understood to be the time in seconds until
 *   expiration. If null is passed explicitly, a default value MAY be used.
 *   If none is set, the value should be stored permanently or for as long as the
 *   implementation allows.
 *
 * @return \Xpl\Cache\Item
 *   The called object.
 */
PHP_METHOD(Xpl_Cache_Item, expiresAfter) {

	zend_class_entry *_6$$7;
	int ZEPHIR_LAST_CALL_STATUS;
	zval *time, *_0$$3, *_1$$3, *_2$$3, *_3$$5, *_4$$5, *_5$$7 = NULL, *_7$$7, *_8$$7 = NULL, *_9$$7 = NULL, *_10$$7 = NULL, *_11$$8, *_12$$8 = NULL, _13$$8, *_14$$8 = NULL;

	ZEPHIR_MM_GROW();
	zephir_fetch_params(1, 1, 0, &time);



	if (Z_TYPE_P(time) == IS_NULL) {
		ZEPHIR_INIT_VAR(_0$$3);
		zephir_time(_0$$3);
		_1$$3 = zephir_fetch_nproperty_this(this_ptr, SL("defaultTtl"), PH_NOISY_CC);
		ZEPHIR_INIT_VAR(_2$$3);
		zephir_add_function(_2$$3, _0$$3, _1$$3);
		zephir_update_property_this(this_ptr, SL("expires"), _2$$3 TSRMLS_CC);
	} else {
		if (Z_TYPE_P(time) == IS_LONG) {
			ZEPHIR_INIT_VAR(_3$$5);
			zephir_time(_3$$5);
			ZEPHIR_INIT_VAR(_4$$5);
			zephir_add_function(_4$$5, _3$$5, time);
			zephir_update_property_this(this_ptr, SL("expires"), _4$$5 TSRMLS_CC);
		} else {
			if (zephir_instance_of_ev(time, zephir_get_internal_ce(SS("dateinterval") TSRMLS_CC) TSRMLS_CC)) {
					_6$$7 = zend_fetch_class(SL("DateTime"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
				ZEPHIR_INIT_VAR(_7$$7);
				zephir_time(_7$$7);
				ZEPHIR_INIT_VAR(_8$$7);
				ZVAL_STRING(_8$$7, "U", ZEPHIR_TEMP_PARAM_COPY);
				ZEPHIR_CALL_CE_STATIC(&_5$$7, _6$$7, "createfromformat", NULL, 0, _8$$7, _7$$7);
				zephir_check_temp_parameter(_8$$7);
				zephir_check_call_status();
				ZEPHIR_CALL_METHOD(&_9$$7, _5$$7, "add", NULL, 0, time);
				zephir_check_call_status();
				ZEPHIR_INIT_NVAR(_8$$7);
				ZVAL_STRING(_8$$7, "U", ZEPHIR_TEMP_PARAM_COPY);
				ZEPHIR_CALL_METHOD(&_10$$7, _9$$7, "format", NULL, 0, _8$$7);
				zephir_check_temp_parameter(_8$$7);
				zephir_check_call_status();
				zephir_update_property_this(this_ptr, SL("expires"), _10$$7 TSRMLS_CC);
			} else {
				ZEPHIR_INIT_VAR(_11$$8);
				object_init_ex(_11$$8, xpl_cache_invalidargumentexception_ce);
				ZEPHIR_INIT_VAR(_12$$8);
				if (Z_TYPE_P(time) == IS_OBJECT) {
					ZEPHIR_INIT_NVAR(_12$$8);
					zephir_get_class(_12$$8, time, 0 TSRMLS_CC);
				} else {
					ZEPHIR_INIT_NVAR(_12$$8);
					zephir_gettype(_12$$8, time TSRMLS_CC);
				}
				ZEPHIR_SINIT_VAR(_13$$8);
				ZVAL_STRING(&_13$$8, "Expiration date must be integer, DateInterval or null, given: \"%s\".", 0);
				ZEPHIR_CALL_FUNCTION(&_14$$8, "sprintf", NULL, 41, &_13$$8, _12$$8);
				zephir_check_call_status();
				ZEPHIR_CALL_METHOD(NULL, _11$$8, "__construct", NULL, 42, _14$$8);
				zephir_check_call_status();
				zephir_throw_exception_debug(_11$$8, "xpl/cache/item.zep", 181 TSRMLS_CC);
				ZEPHIR_MM_RESTORE();
				return;
			}
		}
	}
	RETURN_THIS();

}

/**
 * Returns the time at which the item expires.
 *
 * @return int
 */
PHP_METHOD(Xpl_Cache_Item, getExpiration) {

	

	RETURN_MEMBER(this_ptr, "expires");

}

/**
 * Returns the time to live.
 *
 * @return int
 */
PHP_METHOD(Xpl_Cache_Item, getTtl) {

	zval *_0, *_1, *_2, *_3;

	ZEPHIR_MM_GROW();

	ZEPHIR_INIT_VAR(_0);
	_1 = zephir_fetch_nproperty_this(this_ptr, SL("expires"), PH_NOISY_CC);
	if (zephir_is_true(_1)) {
		_2 = zephir_fetch_nproperty_this(this_ptr, SL("expires"), PH_NOISY_CC);
		ZEPHIR_INIT_VAR(_3);
		zephir_time(_3);
		zephir_sub_function(_0, _2, _3);
	} else {
		zephir_read_property_this(&_0, this_ptr, SL("defaultTtl"), PH_NOISY_CC);
	}
	RETURN_CCTOR(_0);

}

